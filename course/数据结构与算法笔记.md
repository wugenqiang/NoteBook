# 数据结构与算法笔记

> [2020 王道考研 数据结构](https://www.bilibili.com/video/av92191094?p=20)
>
> [陈越 浙大 数据结构](https://www.bilibili.com/video/av18586085?from=search&seid=15780231958273429695)



## 概念

> 如何用程序代码把现实世界的问题**信息化**
>
> 如何用计算机高效地处理这些信息从而创造价值

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318164854.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318164923.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318165004.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318165153.png)

## 算法复杂度

### 时间复杂度

事前预估算法时间开销T(n)与问题规模n的关系(T表示“time”)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318172031.png)

**时间复杂度量级比较**
$$
O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
$$
![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318172252.png)



![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318172823.png)



### 空间复杂度

算法可以**原地工作**——S(n)=O(1)

计算规则与时间复杂度类似



递归型算法

空间复杂度=递归调用的深度



![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318174447.png)



## 栈和队列

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318180913.png)



## 矩阵的压缩存储



### 对称矩阵

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318175047.png)

计算$$\large a_{i,j}$$在压缩矩阵中的下标

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318175521.png)

### 三角矩阵

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318175700.png)

+1个空间是为了存储这个常数c

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318175802.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318180038.png)

### 三对角矩阵

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318180228.png)

数组下标$$k=3*(i-1)-1+j-i+1=2*i+j-3$$

$$i = (k+1)/3 + 1$$

$$j = k-2*i+3$$

### 稀疏矩阵

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200318180607.png)

> 稀疏矩阵在采用压缩存储后将会**失去随机存储的功能**。因为在这种矩阵中，非零元素的分布是没有规律的，为了压缩存储，就将每一个非零元素的值和它所在的行、列号做为一个结点存放在一起，这样的结点组成的线性表中叫三元组表，它已不是简单的向量，所以无法用下标直接存取矩阵中的元素。



## KMP算法

理解三个概念：前缀、后缀、部分匹配值

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200319004201.png)

### 手搓步骤

计算模式串中所有前缀的部分匹配值

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200319004945.png)

匹配成功则向后推进，匹配失败则根据next[]数组回退（j-1 - next[j-1]）步。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200319005345.png)

### 算法实现

```java
public class KMP2 {
    private int next[];
    private String pat;

    public static void main(String[] args) {
        KMP2 kmp = new KMP2("issip");
        int res = kmp.search("mississippi");
        System.out.println("res: " + res);
    }

    public KMP2(String pat) {
        this.pat = pat;
        getNext(pat);
    }

    public void getNext(String pat) {
        char[] p = pat.toCharArray();
        next = new int[p.length];
        next[0] = -1;
        int j = 0;
        int k = -1;
    
        while (j < p.length - 1) {
            if (k == -1 || p[j] == p[k]) {
                next[++j] = ++k;
            } else {
                k = next[k];
            }
        }
    }

    public int search(String text) {
        char[] t = text.toCharArray();
        char[] p = pat.toCharArray();
        int i = 0; // 主串位置
        int j = 0; // 模式串位置
        while (i < t.length && j < p.length) {
            if (j == -1 || t[i] == p[j]) {
                i++; j++;
            } else {
                j = next[j]; // j回退
            }
        }
        if (j == p.length) {
            return i-j;
        } else {
            return -1;
        }
    }


}
```



利用动态规划 二维dp 实现KMP算法

[有限状态机](https://www.zhihu.com/question/31634405)

[labuladong KMP算法详解](https://zhuanlan.zhihu.com/p/83334559)

```java
public class KMP {
    private int[][] dp;
    private String pat;

    public static void main(String[] args) {
        KMP kmp = new KMP("issip");
        int res = kmp.search("mississippi");
        System.out.println("res: " + res);
    }

    public KMP(String pat) {
        this.pat = pat;
        int M = pat.length();
        // dp[状态][字符] = 下个状态
        dp = new int[M][256];
        // base case
        dp[0][pat.charAt(0)] = 1;
        // 影子状态 X 初始为 0
        int X = 0;
        // 构建状态转移图（稍改的更紧凑了）
        for (int j = 1; j < M; j++) {
            for (int c = 0; c < 256; c++) {
                if (pat.charAt(j) == c) {
                    dp[j][c] = j + 1;
                } else {
                    dp[j][c] = dp[X][c];
                }
            }
            // 更新影子状态
            X = dp[X][pat.charAt(j)];
        }
    }

    public int search(String txt) {
        int M = pat.length();
        int N = txt.length();
        // pat 的初始态为 0
        int j = 0;
        for (int i = 0; i < N; i++) {
            // 计算 pat 的下一个状态
            j = dp[j][txt.charAt(i)];
            // 到达终止态，返回结果
            if (j == M) return i - M + 1;
        }
        // 没到达终止态，匹配失败
        return -1;
    }
}
```

## 树

### 基本概念

**n个结点，有n-1个边**

树中一个结点的子结点的个数称为该**结点的度**

树种最大度数称为**树的度**

度大于0的结点为**分支结点**

度为0的结点为**叶子结点**

有序树与无序树

**路径**：树中两个结点之间的路径，且一定是自上而下的。

**路径长度**：路径上所经历边的个数

**森林**：m课互不相交的树的集合

### 树的性质

1. 树中的结点数等于所有结点的度数加1
2. 度为m的树中第i层上至多有$m^{i-1}$个结点($i \ge 1$)
3. 高度为h的m叉树至多有$(m^b-1)/(m-1)$个结点
4. 具有n个结点的m叉树的最小高度为$log_m[n(m-1)+1]$

### 二叉树定义

**二叉树**：每个结点最多有2个子结点

度为2的有序树：每个结点最多有2个子结点 且 必须有一个结点具有2个子结点

二叉树可以为空，而度为2的有序树至少有三个结点。

二叉树的孩子结点始终有左右之分，而度为2的有序树的孩子结点次序是相对的。

---

**满二叉树**：一棵高度为h，且含有$2^h-1$个结点的二叉树为满二叉树。对于编号为i的结点，若存在，其双亲编号为[i/2]，左孩子为2i，右孩子为2i+1。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200323232543.png)

---

**完全二叉树**：设一个高度为h，有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1~n的结点一一对应时，称为完全二叉树。

性质：

1. 若$i \le [n/2]$，则结点i为分支结点，否则为叶子结点。
2. 叶子结点只可能在层次最大的两层出现。对于最大层次的叶子接待你，都依次排列在最左边的位置上。
3. 度为1的结点若存在，则可能有一个，且是编号最大的分支结点，并且孩子结点一定是左节点。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200323233011.png)

---

**二叉排序树**：一棵二叉树，若树非空则具有如下性质：对于任意结点若存在左子树或右子树，则其左子树上所有结点的关键字均小于该结点，右子树上所有结点的关键字均大于该结点。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200323233230.png)

---

**平衡二叉树**：树上任意结点的左子树和右子树的深度之差不超过1。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200323233341.png)



### 二叉树性质

1. 非空二叉树上的叶子结点数等于度为2的结点数加1，即$n_0=n_2+1$

   如何推导：

   $①. n=n_0+n_1+n_2$ 结点总数=$\sum\limits_{i=0}^{2}$度为i的结点数

   $②. n=n_1+2n_2+1$ 结点总数= 边数+1 = $\sum\limits_{i=0}^{2}$度为i的结点数*该结点的出度i

2. 非空二叉树上第k层上至多有$2^{k-1}$个结点($k \ge 1$)

3. 高度为h的二叉树至多有$2^h-1$个结点($h \ge 1$)

4. 结点i所在层次为$[log_2i]+1$

5. 具有n个($n \ge 1$)结点的完全二叉树的高度为$[log_2n]+1$ (由4得)或$[log_2(n+1)]$ (由3得)



### 二叉树存储

**顺序存储**：用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。

- 适合完全二叉树。

- 最坏情况下会非常浪费存储空间。

```c
ElementType tree[MAXSIZE] = {};
```

**链式存储**：用链表来存放二叉树，二叉树中每个结点用链表的一个链结点来存储。

- 含有n个结点的二叉链表，有n+1个空链域。
- 2n-(n-1) = n+1  
- 2n表示总链域数，n个结点，每个结点有两个指针域
- n-1表示非空链域，每个链域指向一个孩子结点，所以n-1个孩子结点就有n-1个非空链域。除了根节点，每个结点都能作为孩子结点，所以是n-1个孩子结点。

```c
typedef struct Node {
	ElementType data;
	struct Node *lchild, *rchild;
} Node, *BiTree;
```



### 二叉树遍历

先序遍历：根，左子树，右子树

中序遍历：左子树，根，右子树

后序遍历：左子树，右子树，根

层次遍历：从左至右，从上至下



递归实现

```c
void PreOrder(BiTree T) {
    if (T != NULL) {
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}

void InOrder(BiTree T) {
    if (T != NULL) {
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
}

void PostOrder(BiTree T) {
    if (T != NULL) {
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        visit(T);
    }
}
```



**中序遍历非递归实现**

1. 初始时依次扫描根节点的所有左侧结点并将他们一一入栈；
2. 出栈一个结点，访问它；
3. 扫描该结点的右孩子结点并将其入栈；
4. 依次扫描右孩子结点的所有左侧结点并一一入栈；
5. 反复该过程直到栈空为止。

```c
void InOrderTraverse(BiTree T) {
    Node *S;
    InitStack(S);
    BiTree p = T;
    while (p || !IsEmpty(S)) {
        if (p) {
            Push(S, p);
            p = p->lchild;
        } else {
            Pop(S, p); visit(p);
            p = p->rchild;
        }
    }
}

void PreOrderTraverse(BiTree T) {
    Node *S;
    InitStack(S);
    BiTree p = T;
    Push(S, p);
    while (p != NULL || !IsEmpty(S)) {
        Pop(S, p);
        visit(p);
        if (p->rchild != NULL) {
            Push(S, p->rchild);
        }
        if (p->lchild != NULL) {
            Push(S, p->lchild);
        }
    }
}
```

**后序遍历非递归实现**

待定。



**层次遍历**

1. 初始时将根入队并访问根节点
2. 若有左子树，则将左子树的根入队
3. 若有右子树，则将右子树的根入队
4. 然后出队，访问该结点
5. 反复该过程直到队列为空

```c
void levelOrder(BiTree T) {
    InitQueue(Q);
    BiTree p;
    EnQueue(Q, T);
    while (!isEmpty(Q)) {
        DeQueue(Q, p);
        visit(p);
        if (p->lchild != NULL)
            EnQueue(Q, p->lchild);
        if (p->rchild != NULL)
            EnQueue(Q, p->rchild);
    }
}
```



### 遍历序列构造二叉树

先（后）序遍历序列和中序遍历序列可以确定一棵二叉树。

而后序遍历序列和先序遍历序列不可以确定一棵二叉树。



### 线索二叉树

线索化：

- 若无左子树，则将左指针指向其前驱结点；
- 若无右子树，则将右指针指向其后继结点。

```c
typedef struct ThreadNode {
	ElementType data;
	struct Node *lchild, *rchild;
    int ltag, rtag;
} ThreadNode, *ThreadTree;
// l(r)tag :
// 0: l(r)child域指向的是孩子结点
// 1: l(r)child域指向的是前驱(后继)结点
```



中序线索二叉树寻找对应结点的前驱与后继更加方便。我们主要研究中序线索二叉树。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329152739.png)



**中序线索二叉树**

- 前驱结点
  - 若左指针为线索，则其指向的结点为前驱结点
  - 若左指针为左孩子，则其左子树的最右侧结点为前驱结点
- 后继结点
  - 若右指针为线索，则其指向的结点为后继结点
  - 若右指针为右孩子，则其右子树的最左侧结点为后继结点

**中序线索二叉树的线索化实现**

```c
void InThread(ThreadTree &p, ThreadTree &pre) {
    if (p == NULL) return;
    InThread(p->lchild, pre);
    if (p->lchild == NULL) {
        p->lchild = pre;
        p->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = p;
        pre->rtag = 1;
    }
    pre = p;
    InThread(p->rchild, pre);
}
```

得到的中序线索二叉树：

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329154148.png)

还可以将剩余两个指针利用起来，指向一个头节点的前驱与后继。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329154206.png)

**中序线索二叉树遍历**

```c
// 找到中序遍历的第一个结点
ThreadNode* FirstNode(ThreadNode *p) {
    while (p->ltag == 0)
        p = p->lchild;
    return p;
}
// 找下一个结点
ThreadNode* NextNode(ThreadNode *p) {
    if (p->rtag == 0) // 如果右指针是孩子结点
        return FirstNode(p->rchild); // 找右孩子的左子树中第一个结点，为我们要的后继结点
    else // 如果右指针是线索
        return p->rchild; // rchild就是我们要的后继结点
}

// 中序线索树的遍历
void InOrder(ThreadNode *T) {
    for (ThreadNode *p=FirstNode(T); p != NULL; p = NextNode(p)) {
        visit(p);
    }
}
```

### 树的存储

- 双亲表示法

  采用一组连续的存储空间来存储每个结点，同时在每个节点中增设一个伪指针，指示双亲结点在数组中的位置。根结点的下标为0，其伪指针域为-1。

  ```c
  typedef struct {
      ElemType data;
      int parent;
  } PTNode;
  
  typedef struct {
      PTNode nodes[MAX_TREE_SIZE];
      int n;
  } PTree;
  ```

  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329172140.png)

- 孩子表示法

  将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表。

  ```c
  // 孩子结点
  typedef struct {
      int child; // 孩子结点的下标
      struct CNode *next;
  } CNode;
  
  // 根节点
  typedef struct {
      ElemType data;
      struct CNode *child;
  } PNode;
  
  typedef struct {
      PNode nodes[MAX_TREE_SIZE];
      int n;
  } CTree;
  ```

  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329172614.png)

- 孩子兄弟表示法

  以二叉链表作为树的存储结构，又称二叉树表示法。

  左孩子，右兄弟

  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329172759.png)

  ```c
  typedef strct CSNode {
      ElemType data;
      struct CSNode *firstchild, *nextsibling;
  } CSNode, CSTree;
  ```

  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329172930.png)



**优缺点比较**

|                | 优点                                             | 缺点                     |
| -------------- | ------------------------------------------------ | ------------------------ |
| 双亲表示法     | 寻找结点的双亲结点效率高                         | 寻找结点的孩子结点效率低 |
| 孩子表示法     | 寻找结点的孩子结点效率高                         | 寻找结点的双亲结点效率低 |
| 孩子兄弟表示法 | 寻找结点的孩子结点效率高，方便实现树转换成二叉树 | 寻找结点的双亲结点效率低 |



### 树、森林与二叉树的转换

**树与二叉树的转换**

规则：每个结点左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点。

**森林与二叉树的转换**

规则：将每一棵树转换为二叉树，将每棵二叉树的根依次作为上一棵二叉树的右子树。



转换是唯一的



### 树的遍历

- 先根遍历

  若树非空，先访问根节点，再按从左至右的顺序遍历根节点的每棵子树。

- 后根遍历

  若树非空，则先按从左到右的顺序遍历根节点的每棵子树，再访问根节点。

- 层次遍历



⭐树的先根遍历序列与这棵树对应二叉树的先序遍历序列相同。

⭐树的后根遍历序列与这棵树对应二叉树的**中序**遍历序列相同。



### 森林的遍历

- 先序遍历

  若森林非空，则，

  - 访问森林中第一棵树的根节点

  - 先序遍历第一棵树的子树森林

  - 先序遍历除去第一棵树之后的剩余的树构成的森林

- 中序遍历

  若森林非空，则，

  - 中序遍历第一棵树的根节点的子树森林
  - 访问第一棵树的根节点
  - 中序遍历除去第一棵树之后剩余的树构成的子树森林



⭐森林的先序遍历序列与森林对应二叉树的先序遍历序列相同。

⭐森林的中序遍历序列与森林对应二叉树的中序遍历序列相同。



### 遍历序列的对应关系

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329181130.png)

## 树的应用-并查集

并查集是一种简单的集合表示。

通常用树的**双亲表示法**作为并查集的存储结构。

定义以下几个方法：

- Initial(S) 将集合S中的每个元素都初始化为只有一个单元素的子集合

- Union(S, Root1, Root2)

  把集合S中的子集合（互不相交）Root2并入子集合Root1

- Find(S, X)

  查找集合S中单元素x所在子集合，并返回该子集合的名字。



![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329182810.png)



```c
int UFSets[SIZE];
void Initial(int S[]) {
    for (int i = 0; i < size; i++)
        s[i] = -1;
}

int Find(int S[], int x) {
    while(S[x] >= 0)
        x = S[x];
    return x;
}

void Union(int S[], int Root1, int Root2) {
    S[Root1] += S[Root2]; //更新Root1的根节点值
    S[Root2] = Root1; //更新Root2的根节点值
}
```



## 树的应用-二叉排序树

BST，也称二叉查找树。

二叉排序树或者为空树，或者为非空树，当为非空树时有如下特点：

1. 若左子树非空，则左子树上所有结点关键字均**小于**根节点的关键字。
2. 若右子树非空，则右子树上所有结点关键字均**大于**根节点的关键字。

3. 左右子树本身也分别是一棵二叉排序树。



⭐中序遍历二叉排序树，得到的是一个递增的有序序列。



**查找**

二叉树非空时，查找根节点，若相等则查找成功；

若不等，则当小于根节点值时，查找左子树；当大于根节点值时，查找右子树。

当查找到叶节点仍没查找到相应的值，则查找失败。

**非递归算法实现查找算法**

```c
BSTNode *BST_Search(BiTree T, ElemType key, BSTNode *&p) {
    p = NULL;
    while (T!=NULL && key!=T->data) {
        p = T;
        if (key < T->data)
            T=T->lchild;
        else
            T=T->rchild;
    }
    return T;
}
```

**插入操作**

若二叉排序树为空，则直接插入结点；

若二叉排序树非空，

​	当值小于根节点时，插入左子树；

​	当值大于根节点时，插入右子树；

​	当值等于根节点时，不进行插入；

```c
int BST_Insert(BiTree &T, KeyType k) {
    if (T == NULL) {
        T = (BiTree)malloc(sizeof(BSTNode));
        T->key = k;
        T->lchild = T->rchild = NULL;
        return 1;
    } else if (k == T->key)
        return 0;
    else if (k < T->key)
        return BST_Insert(T->lchild, k);
    else
        return BST_Insert(T->rchild, k);
}
```

**构造二叉排序树**

不断调用插入函数来构造。

```c
void Create_BST(BiTree &T, KeyType str[], int n) {
    T = NULL;
    int i = 0;
    while (i < n) {
        BST_Insert(T, str[i]);
        i++;
    }
}
```

**删除操作**

若被删结点是叶子结点，则可以直接删除。

若被删结点z只有一棵子树，则让z的子树成为z父结点的子树，代替z结点。

若被删除结点z有两棵子树，则让z的中序序列直接后继代替z，并删去直接后继结点。



在二叉排序树中删除并插入某个结点，得到的二叉排序树不一定相同。



**查找效率**

平均查找长度ASL取决于树的高度。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329202122.png)









## 回溯算法

### 八皇后问题

该问题是十九世纪著名的数学家高斯1850年提出：
在8*8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。



